## `set()` (集合)

`set` は重複する要素を許可しないコレクションです。要素の追加、削除、存在チェックが高速です。

```python
my_set = {1, 2, 3, 2, 1}
print(my_set)  # {1, 2, 3} (重複が除去される)

my_set.add(4)
print(my_set)  # {1, 2, 3, 4}

my_set.add(2) # 既に存在するので変更なし
print(my_set)  # {1, 2, 3, 4}

print(2 in my_set) # True
## `map()` 関数

`map(関数, イテラブル)` は、イテラブルの各要素に指定した関数を適用し、その結果のイテレータを返します。

```python
numbers = [1, 2, 3, 4]
squared_numbers = list(map(lambda x: x**2, numbers))
print(squared_numbers) # [1, 4, 9, 16]
```
`for` ループで同様の処理を記述するよりも簡潔になります。

## `deque` (double-ended queue)

`collections` モジュールの `deque` は、両端から要素の追加・削除が高速にできるデータ構造です。キュー（FIFO: First In, First Out）やスタック（LIFO: Last In, First Out）として利用できます。

```python
from collections import deque

q = deque()
q.append(1)    # 右端に追加
q.append(2)
q.appendleft(0) # 左端に追加
print(q)       # deque([0, 1, 2])

val_right = q.pop()      # 右端から削除
print(val_right) # 2
print(q)         # deque([0, 1])

val_left = q.popleft()   # 左端から削除 (リストのpop(0)より高速)
print(val_left)  # 0
print(q)         # deque([1])
```
キューの操作が必要な幅優先探索 (BFS) などで非常に役立ちます。

## `sort()` の計算量

リストのソート（`list.sort()` や `sorted()`）の平均計算量は $O(N \log N)$ です。


## `Counter()` のブール評価

`collections.Counter` オブジェクトは、空であれば `False`、中身があれば `True` と評価されます。これは、Pythonの `dict`, `list`, `set` など他のコレクション型と同じ挙動です。

```python
from collections import Counter

c1 = Counter()
print(bool(c1)) # False

c2 = Counter('hello')
print(bool(c2)) # True
```

## Pythonの組み込みデータ構造まとめ

### 特徴

| 特徴       | リスト (`list`) | タプル (`tuple`) | `deque` |
| :--------- | :-------------- | :--------------- | :------ |
| 変更できる？ | ✅ できる       | ❌ できない      | ✅ できる |
| 書き方     | `[1, 2, 3]`     | `(1, 2, 3)`      | `deque([1, 2, 3])` |
| 要素のアクセス | `a[0]` で可能   | `a[0]` で可能    | `q[0]` で可能 |

### 比較

* **リスト (`list`)**:
    * 要素の変更、追加、削除が可能です。
    * 一般的な動的配列として最もよく使われます。
* **タプル (`tuple`)**:
    * 要素の変更、追加、削除ができません（不変）。
    * `list` よりも`for` 文などの処理がわずかに速い場合があります。
    * 辞書や集合のキーとして使用できます（ハッシュ可能であるため）。
    * **使うべき場面**: データを固定したいとき（誤って変更されたくない）、座標 `(y, x)` のようにセットで使うデータを表現するとき、辞書のキーとして使いたいとき。
* **`deque`**:
    * 両端からの要素の追加・削除が高速です。
    * `list` の `pop(0)` や `insert(0, x)` は要素のシフトが発生するため $O(N)$ の計算量がかかりますが、`deque` の `popleft()` や `appendleft()` は $O(1)$ です。
    * **使うべき場面**: キュー（FIFO）やスタック（LIFO）の実装、特に幅優先探索 (BFS) で活躍します。

### 追加・削除・変換技 (再掲)

| 操作     | `list`             | `tuple` | `deque`            |
| :------- | :----------------- | :------ | :----------------- |
| 末尾追加 | `append(x)`        | ❌ 不可 | `append(x)`        |
| 左端追加 | `insert(0, x)` (遅い) | ❌ 不可 | `appendleft(x)` (高速) |
| 末尾削除 | `pop()`            | ❌ 不可 | `pop()`            |
| 左端削除 | `pop(0)` (遅い)    | ❌ 不可 | `popleft()` (高速) |
| 書き換え | `a[0] = x`         | ❌ エラー | `q[0] = x`         |

## グラフ (Graph) と木 (Tree) の違い

| 特徴             | グラフ (Graph)           | 木 (Tree)               |
| :--------------- | :----------------------- | :---------------------- |
| 閉路 (Cycle)     | ⭕️ 存在してもOK           | ❌ 存在してはダメ        |
| 辺の数           | ノード数 N に対して $N-1$ 以上でもOK | ノード数 N に対して必ず $N-1$ 本 |
| 連結性           | 複数の連結成分があってもOK | 全て繋がっていなければダメ（連結） |

## 文字列 (`str`) の特性

文字列は不変 (immutable) なシーケンスです。そのため、個別の文字を上書きしたり変更したりすることはできません。

```python
s = "hello"
# s[0] = 'H' # これはエラーになります
```

## エスケープシーケンス

文字列内で特殊な意味を持つ文字を表現するために使用します。

| エスケープシーケンス | 意味       |
| :------------------- | :--------- |
| `\n`                 | 改行       |
| `\t`                 | タブ       |
| `\\`                 | バックスラッシュ |
| `\'`                 | シングルクォート |
| `\"`                 | ダブルクォート |

**例**:
```python
print('私はキカガクです。\nよろしくお願いします。')
# 出力:
# 私はキカガクです。
# よろしくお願いします。

print('私はキカガクです。\nよろしくお願いします。\n\tタブ1\n\tタブ2')
# 出力:
# 私はキカガクです。
# よろしくお願いします。
# 	タブ1
# 	タブ2
```
