# アルゴリズムとデータ構造用語集

| 英語 (Category)           | 日本語訳               | 説明                                                                                                                                   | 例                                                                                                      |
| :------------------------ | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------ |
| **Array** | 配列                   | 同じ型のデータを順序付けて格納するデータ構造。インデックスでアクセスします。                                                           | `[1, 2, 3, 4, 5]`, `["apple", "banana"]`                                                                |
| **String** | 文字列                 | 文字の並びを表すデータ型。不変であることが多いです。                                                                                   | `"Hello World"`, `"Python"`                                                                             |
| **Hash Table** / **Hash Map** | ハッシュテーブル / ハッシュマップ | キーと値のペアを格納し、キーをハッシュ関数でインデックスに変換して高速アクセスを実現します。                                           | Pythonの`dict` (`{"name": "Alice", "age": 30}`)                                                         |
| **Dynamic Programming** | 動的計画法             | 複雑な問題を重複するサブ問題に分割し、それぞれの解を記憶して計算量を削減する手法です。                                                   | フィボナッチ数列、ナップサック問題、最長共通部分列                                                      |
| **Math** | 数学                   | アルゴリズム問題において、基本的な数学の知識（四則演算、剰余、素数など）や、より高度な概念を応用する問題のカテゴリです。                 | 最大公約数 (GCD)、素数判定、階乗                                                                        |
| **Sorting** | ソート / 並べ替え      | データの集合を特定の順序（昇順、降順など）に並べ替えるアルゴリズムです。                                                               | バブルソート、マージソート、クイックソート                                                              |
| **Greedy** | 貪欲法                 | 各段階でその時点での最善と思われる選択を繰り返し行うことで、全体として最適解を得ようとするアルゴリズムです。                             | 硬貨のお釣り計算、活動選択問題                                                                          |
| **Depth-First Search (DFS)** | 深さ優先探索           | グラフやツリーを可能な限り深く探索し、行き止まりになったら前のノードに戻り、別のパスを探索するアルゴリズムです。                     | 迷路の探索、グラフの連結成分検出                                                                        |
| **Binary Search** | 二分探索               | ソートされた配列の中から、目的の要素を効率的に見つけるための探索アルゴリズム。探索範囲を半分に絞り込みます。                             | ソート済み配列から特定の数値を探す                                                                      |
| **Database** | データベース           | 構造化されたデータを効率的に管理するためのシステム。競技プログラミングでは直接問われることは稀ですが、データ管理の概念として重要です。 | リレーショナルデータベース (MySQL)                                                                      |
| **Matrix** | 行列                   | 行と列で構成される数値の二次元配列。画像処理、グラフの表現などに使われます。                                                           | 画像データ、グラフの隣接行列                                                                            |
| **Tree** | 木                     | ノード（頂点）とエッジ（辺）からなる階層的なデータ構造。根ノードから始まり、子ノードへと分岐し、サイクルを持ちません。               | ファイルシステム、HTMLのDOMツリー                                                                       |
| **Breadth-First Search (BFS)** | 幅優先探索             | グラフやツリーの探索アルゴリズムの一つ。現在のノードから隣接するすべてのノードを探索し、その後にそれらのノードの隣接ノードを探索します。 | 最短経路問題 (重みなしグラフ)、迷路の最短脱出経路                                                       |
| **Bit Manipulation** | ビット操作 / ビット演算 | データをビットレベルで操作する技術。AND, OR, XOR, NOT, シフト演算などを使い、数値の特定ビットを調べたり、高速な計算を行ったりします。 | 数値の偶奇判定、集合のビットマスク表現                                                                  |
| **Two Pointers** | 二つのポインタ / 双方向ポインタ | 配列や文字列などを操作する際に、異なる位置にある2つのポインタ（インデックス）を使って効率的に処理を進めるテクニックです。           | ソート済み配列から合計値がXになる2つの要素を探す、回文の判定                                            |
| **Prefix Sum** | 累積和                 | 配列の各要素までの合計値を事前に計算しておくことで、特定の範囲の合計値を高速に求めることができるテクニックです。                       | 区間和の高速計算                                                                                        |
| **Heap (Priority Queue)** | ヒープ (優先度付きキュー) | 特殊なツリーベースのデータ構造で、親ノードが常に子ノードよりも大きい（または小さい）という性質を持ちます。                           | Dijkstra's Algorithm、スケジューリング問題                                                              |
| **Simulation** | シミュレーション       | 問題の記述通りに、手順やイベントを忠実にコードで再現する問題です。                                                                   | ゲームのルールに従って盤面の状態を更新する、特定の条件でオブジェクトがどのように移動するかを追跡する    |
| **Binary Tree** | 二分木                 | 各ノードが最大2つの子ノード（左の子と右の子）を持つ木構造です。                                                                        | 二分探索木 (BST)                                                                                        |
| **Stack** | スタック               | LIFO (Last-In, First-Out) の原則に基づいてデータを格納・取得するデータ構造です。最後に入れたものが最初に出てきます。             | 関数の呼び出しスタック、ブラウザの「戻る」ボタンの履歴、括弧の整合性チェック                            |
| **Graph** | グラフ                 | ノード（頂点）とそれらを結ぶエッジ（辺）からなるデータ構造。様々な関係性を表現するのに使われます。                                     | ソーシャルネットワーク (友人関係)、道路網、ウェブページのリンク構造                                     |
| **Counting** | 数え上げ               | 特定の条件を満たす要素の数、組み合わせの数、順列の数などを数える問題です。                                                           | 配列内の特定の数値の出現回数を数える、条件を満たす部分集合の数を数える                                  |
| **Sliding Window** | スライディングウィンドウ | 配列や文字列の部分配列を、固定または可変サイズの「ウィンドウ」として扱い、そのウィンドウを移動させながら問題を解くテクニックです。   | 部分配列の最大合計値を求める (サイズKのウィンドウ)、重複しない文字の最長部分文字列を見つける          |
| **Design** | 設計                   | データ構造やクラスを設計する問題。特定の操作を効率的に行うためのデータ構造を選んだり、複数のコンポーネント間の相互作用を考慮したりします。 | LruCacheの実装、データストリームを処理するシステムの設計                                                |
| **Enumeration** | 列挙                   | 特定の条件を満たすすべての可能性や組み合わせを、漏れなく重複なくリストアップする問題です。                                           | 集合のすべての部分集合を列挙する、特定のパスのすべての組み合わせを列挙する                            |
| **Backtracking** | バックトラック         | 解を構築するために、選択肢を一つずつ試していき、もしその選択肢が最終的な解に繋がらないと判断したら、前の状態に戻って別の選択肢を試すアルゴリズムです。 | Nクイーン問題、数独ソルバー、部分集合の合計 (Subset Sum)                                                  |
| **Union Find** | Union-Find / 素集合データ構造 | 互いに素な集合を管理するためのデータ構造。要素がどの集合に属するかを効率的に判別し、2つの集合を結合できます。                      | グラフの連結成分を検出する、Kruskal's Algorithm (最小全域木)                                            |
| **Linked List** | 連結リスト             | 各要素（ノード）が次の要素へのポインタ（または参照）を持つデータ構造。配列と異なり、連続したメモリ領域に格納される必要がなく、要素の挿入や削除が高速です。 | 単方向連結リスト、二重連結リスト                                                                        |
| **Number Theory** | 数論                   | 整数とその性質（素数、約数、合同式など）を扱う数学の分野。                                                                         | 素因数分解、モジュロ演算（剰余計算）を使った問題、フェルマーの小定理                                    |
| **Ordered Set** | 順序付き集合           | 要素がソートされた順序で格納され、要素の挿入、削除、検索に加え、指定した範囲の要素の取得や、特定の要素の順位などを効率的に行えるデータ構造です。 | Javaの`TreeSet`                                                                                         |
| **Monotonic Stack** | 単調スタック           | スタック内の要素が常に単調増加または単調減少する性質を持つスタック。次のより大きい/小さい要素を高速に見つけるなどの問題に利用されます。 | Next Greater Element (次の大きい要素)、ヒストグラムの最大矩形                                           |
| **Segment Tree** | セグメントツリー       | 配列の範囲クエリ（区間和、区間最小値など）を高速に処理できるツリーベースのデータ構造です。                                           | 区間内の最大値/最小値、合計値を高速に取得する                                                           |
| **Trie** | トライ / プレフィックスツリー | 文字列を効率的に格納・検索するためのツリーベースのデータ構造。共通のプレフィックスを持つ文字列が同じパスを共有します。               | 辞書内の単語検索、オートコンプリート機能、IPルーティングテーブル                                        |
| **Combinatorics** | 組合せ論               | 集合の要素の組み合わせや順列、数え上げなどを研究する数学の分野。                                                                   | n個の中からk個を選ぶ組み合わせの数 (nCk)、順列の数 (nPn)                                                |
| **Bitmask** | ビットマスク           | ビット操作を応用し、整数をビットの並びとして扱い、集合の状態や複数のブール値を効率的に表現するテクニックです。                       | 集合の要素の有無をビットで表現する、動的計画法で部分集合の状態を表す                                    |
| **Queue** | キュー                 | FIFO (First-In, First-Out) の原則に基づいてデータを格納・取得するデータ構造です。最初に入れたものが最初に出てきます。             | プリンタのスプール (印刷待ち行列)、BFS (幅優先探索) のノード探索                                         |
| **Recursion** | 再帰                   | 関数が自分自身を呼び出すプログラミング技法。問題をより小さな同じ形式のサブ問題に分割し、再帰的に解決します。                       | 階乗の計算、フィボナッチ数列、木のトラバーサル                                                          |
| **Divide and Conquer** | 分割統治法             | 問題を同じ形式のより小さなサブ問題に分割し、それぞれのサブ問題を独立して解決し、その解を結合して元の問題の解を得るアルゴリズム設計パラダイムです。 | マージソート、クイックソート、最大部分配列問題                                                          |
| **Binary Indexed Tree (BIT)** / **Fenwick Tree** | Binary Indexed Tree (BIT) / フェンウィック木 | 配列の要素の更新と、特定の区間の累積和（または他の二項演算）のクエリを、両方とも効率的に処理できるデータ構造です。 | 要素の更新と区間和のクエリが頻繁に行われる問題                                                          |
| **Memoization** | メモ化                 | 計算コストの高い関数の結果を記憶しておき、同じ入力が再度発生した際に再計算をスキップすることでパフォーマンスを向上させる最適化技法です。 | 再帰的なフィボナッチ数列の計算 (重複計算の削減)                                                         |
| **Hash Function** | ハッシュ関数           | 任意のサイズのデータを固定サイズのデータ（通常は数値）に変換する関数。主にハッシュテーブルでのキーのマッピングなどに使われます。     | 文字列を数値に変換してハッシュテーブルのインデックスにする                                              |
| **Geometry** | 幾何学                 | 点、線、平面、図形などの空間的な関係や性質を扱う数学の分野。                                                                       | 2点間の距離の計算、多角形の面積計算、線分の交差判定                                                     |
| **Binary Search Tree (BST)** | 二分探索木             | 各ノードが、左の子孫ノードの値よりも大きく、右の子孫ノードの値よりも小さいという性質を持つ二分木。探索、挿入、削除が効率的に行えます。 | データの高速な検索、ソートされたデータの動的な管理                                                      |
| **String Matching** | 文字列マッチング       | ある文字列（テキスト）の中に、特定のパターン文字列が存在するかどうか、またはどこに存在するかを効率的に見つけるアルゴリズムです。     | KMPアルゴリズム、Rabin-Karpアルゴリズム、テキストエディタの検索機能                                   |
| **Topological Sort** | トポロジカルソート     | 有向非巡回グラフ (DAG) のノードを、すべての有向エッジ `u -> v` に対して `u` が `v` より前に来るように線形に並べ替えるアルゴリズムです。 | タスクの依存関係の解決 (どのタスクを先に実行すべきか)、コースの履修順序                              |
| **Shortest Path** | 最短経路               | グラフ上で、あるノードから別のノードまでの経路の中で、辺の重みの合計が最小となる経路を見つける問題です。                           | Dijkstra's Algorithm (非負の辺重み)、Bellman-Ford Algorithm (負の辺重み)                                |
| **Rolling Hash** | ローリングハッシュ     | 文字列の部分文字列のハッシュ値を効率的に計算する手法。隣接する部分文字列のハッシュ値を効率的に更新できます。                       | Rabin-Karpアルゴリズムでの文字列マッチング、最長共通部分文字列の発見                                    |
| **Game Theory** | ゲーム理論             | 複数のプレイヤーがいて、それぞれの行動が互いに影響し合う状況での最適な戦略を分析する数学の分野です。                                   | ニムゲームの勝敗判定、Grundy数を使った複合ゲームの解析                                                  |
| **Interactive** | インタラクティブ (対話型) | 問題解決の過程で、プログラムがジャッジ（判定システム）と対話しながら解を導き出すタイプの問題です。                                   | 二分探索を使って秘密の数を見つける問題、特定の要素の位置を問い合わせる                                  |
| **Data Stream** | データストリーム       | データが連続的に、あるいは大量に流入し、一度にすべてをメモリにロードできない状況で処理を行う問題です。                             | データストリームの中央値を見つける、ストリーム内の上位K個の頻出要素を見つける                           |
| **Monotonic Queue** | 単調キュー             | キュー内の要素が常に単調増加または単調減少する性質を持つキュー。スライディングウィンドウの最小値/最大値問題などで効率的に利用されます。 | スライディングウィンドウ内の最大値/最小値を見つける                                                   |
| **Brainteaser** | 脳トレ / 謎解き        | 特定のアルゴリズムやデータ構造の知識よりも、論理的思考力、ひらめき、巧妙な観察が必要となる問題です。                                   | 特定のパズルを解く、一見単純だが、巧妙なトリックがある問題                                              |
| **Doubly-Linked List** | 二重連結リスト         | 各ノードが次のノードへのポインタだけでなく、前のノードへのポインタも持つ連結リスト。双方向への効率的な移動が可能です。             | LRUキャッシュの実装、ブラウザの「戻る」「進む」機能                                                     |
| **Randomized** | 乱択アルゴリズム       | 乱数を利用して解を導くアルゴリズム。多くの場合、確定的なアルゴリズムよりも高速に、あるいはよりシンプルに問題を解決できます。         | クイックソートのピボット選択、Miller-Rabin素数判定法、遺伝的アルゴリズム                                |
| **Merge Sort** | マージソート           | 分割統治法に基づくソートアルゴリズム。配列を半分に分割し、それぞれをソートしてから、2つのソート済み配列をマージして1つのソート済み配列を生成します。 | 外部ソート (メモリに収まらないデータ)、転倒数の計算                                                       |
| **Counting Sort** | 計数ソート             | 要素が非負の整数であり、その範囲が比較的狭い場合に非常に効率的なソートアルゴリズム。各要素の出現回数を数えてソート済み配列を構築します。 | IDのような小さな範囲の整数をソートする                                                                  |
| **Iterator** | イテレータ             | コレクションの要素に順番にアクセスするためのオブジェクト。要素をメモリに一度にすべてロードすることなく、一つずつ処理できます。     | Pythonの`for`ループ、ジェネレータ                                                                       |
| **Concurrency** | 並行性 / 並列性        | 複数のタスクが同時に実行されるようにシステムを設計する概念。スレッド、プロセス、ロック、セマフォなどの概念が含まれます。             | マルチスレッドプログラミング、ウェブサーバーの設計                                                      |
| **Probability and Statistics** | 確率と統計             | 確率論や統計学の概念（期待値、確率分布、平均、分散など）を応用して問題を解くカテゴリです。                                           | サイコロの目の期待値計算、ランダムイベントの発生確率                                                    |
| **Quickselect** | クイックセレクト       | 配列の中からk番目に小さい（または大きい）要素を見つけるためのアルゴリズム。                                                           | 配列の中央値を見つける (k = N/2)                                                                        |
| **Suffix Array** | 接尾辞配列             | 文字列のすべての接尾辞を辞書順にソートした配列。文字列のマッチングやパターン探索などに利用されます。                                   | 文字列のパターン検索、テキスト圧縮アルゴリズム                                                          |
| **Line Sweep** | 走査線法 / スイープラインアルゴリズム | 幾何学的問題やインターバルに関する問題を解く際に、想像上の「走査線」を平面上または直線上を移動させながらイベントを処理していくアルゴリズムです。 | 線分の交差判定、矩形の重なりの面積                                                                      |
| **Bucket Sort** | バケットソート         | 要素を複数の「バケット」（桶）に分割し、各バケットを個別にソートしてから結合するソートアルゴリズムです。                               | 0から1の範囲の浮動小数点数ソート                                                                        |
| **Minimum Spanning Tree** | 最小全域木 (MST)       | 連結された重み付き無向グラフにおいて、すべての頂点を結ぶ部分グラフであり、かつ辺の重みの合計が最小となる木です。                   | Kruskal's Algorithm, Prim's Algorithm、ネットワークケーブルの配線コストの最小化                       |
| **Shell** | シェル                 | 通常、オペレーティングシステムとの対話インターフェースを指します。                                                                   | ファイルシステムの操作、プロセス管理                                                                    |
| **Reservoir Sampling** | リザーバーサンプリング | データの総数が不明または非常に大きいストリームから、ランダムにK個のサンプルを均一に選択するアルゴリズムです。                          | 大規模なログファイルからランダムな行を選択する                                                          |
| **Strongly Connected Component (SCC)** | 強連結成分             | 有向グラフにおいて、任意の2つの頂点 `u` と `v` の間に、`u` から `v` へも `v` から `u` へも到達可能なパスが存在するような頂点集合の最大集合です。 | グラフの循環を検出する、2-SAT問題の解決                                                                 |
| **Eulerian Circuit** | オイラー路 / オイラー閉路 | グラフ内のすべての辺を正確に一度だけ通る経路（路）または閉路（サーキット）です。                                                     | 一筆書きの問題                                                                                          |
| **Radix Sort** | 基数ソート             | 整数を各桁（基数）ごとにソートする非比較ソートアルゴリズム。                                                                       | 電話番号リストのソート、文字列のソート (特定のアルファベットセットの場合)                              |
| **Rejection Sampling** | 棄却サンプリング       | 目的の確率分布からのサンプルを直接生成するのが難しい場合に、別の提案分布からサンプルを生成し、特定の基準に基づいてそのサンプルを受け入れるか棄却するかを決定する手法です。 | 複雑な確率分布からのサンプリング                                                                        |
| **Biconnected Component** | 二重連結成分 (BCC)     | 無向グラフにおいて、1つの頂点（関節点）を取り除いてもグラフが連結性を保つような最大の部分グラフです。                                   | ネットワークの脆弱性分析                                                                                |
